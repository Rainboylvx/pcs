---
_id: "luogu-P3959"
title: "[NOIP2017 提高组] 宝藏"
date: 2023-08-01 16:07
update: 2023-08-01 16:07
author: Rainboy
tags:
    - 状态压缩
source: 
    - 
      oj: luogu-P3959
      url: https://www.luogu.com.cn/problem/P3959
---

@[toc]

## 题目



### 题目描述

参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。

小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远，也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。

小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。

在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。

新开发一条道路的代价是 $\mathrm{L} \times \mathrm{K}$。其中 $L$ 代表这条道路的长度，$K$ 代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。

请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。




### 输入格式
第一行两个用空格分离的正整数 $n,m$，代表宝藏屋的个数和道路数。

接下来 $m$ 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏屋的编号（编号为 $1-n$），和这条道路的长度 $v$。




### 输出格式

一个正整数，表示最小的总代价。




### 样例



输入/输出 # 1

::: line
```
4 5 
1 2 1 
1 3 3 
1 4 1 
2 3 4 
3 4 1 
 
```

```
4
```
:::

输入/输出 # 2

::: line
```
4 5 
1 2 1 
1 3 3 
1 4 1 
2 3 4 
3 4 2  
```

```
5
```
:::





### 说明/提示
 ![](https://cdn.luogu.com.cn/upload/pic/10868.png) 

【样例解释 $1$】

小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \to 4$，挖掘了 $4$ 号宝藏。还开发了道路 $4 \to 3$，挖掘了 $3$ 号宝藏。

工程总代价为 $1 \times 1 + 1 \times 1 + 1 \times 2  = 4 $。

【样例解释 $2$】

小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \to 3$，挖掘了 $3$ 号宝藏。还开发了道路 $1 \to 4$，挖掘了 $4$ 号宝藏。

工程总代价为 $1 \times 1 + 3 \times 1 + 1 \times 1  = 5$。


【数据规模与约定】

对于 $ 20\%$ 的数据： 保证输入是一棵树，$1 \le n \le 8$，$v \le 5\times 10^3$ 且所有的 $v$ 都相等。

对于 $40\%$ 的数据： $1 \le n \le 8$，$0 \le m \le 10^3$，$v \le 5\times 10^3$ 且所有的 $v$ 都相等。

对于 $ 70\%$ 的数据： $1 \le n \le 8$，$0 \le m \le 10^3$，$v \le  5\times 10^3$。

对于 $ 100\%$ 的数据： $1 \le n \le 12$，$0 \le m \le 10^3$，$v \le  5\times 10^5$。

---

$\text{upd 2022.7.27}$：新增加 $50$ 组 Hack 数据。



## 解析


看完题目之后,发现

- 最后这一定是一树,根据树的性质
- 这里的n非常小,不是搜索就是状压,也可能是是状压+搜索

![1.svg](./1.svg)

所谓的状压,本质上就是对集合的操作,比如,交集,并集,子集,判断一个点是否在集合内,一个集合是否是另一个集合的子集,等

显然我们可以写出一个状态转移方程,状态转移方程还是比较好写的


```math
f[s_1][i] = min\{f[s_0][i-1]\} + sum * i
```
- $f[s_1][i]$表示第i层的状态为$s_1$时最小值
- ``s_0``表示``s_1``的子集,
- `sum`表示从`s_0`出发的到达`s_1`集合的最小边集的和.

对`s_1`来说,如何判断`s_0`是不是合法的集合呢,也就是`s_0`能不能转移到`s_1`?

- 先求出`s_1`对`s_0`的补集`s_x`(就是在s1,但不在s0中的点)
- 再根据所有从`s_0`出发的边,求出`s_y`,(`s_0`集合能到达的点的集合,这些点不在`s_0`上)
- 哪果`s_x`是`s_y`的子集,那`s_0`就是合法的子集

所以我们需要预先处理所有的`s_0`的`s_y`,时间为`2^12 * m = 4096*10^3 = 4e7`,可以接受

$Q$: 这样转移,会不会得出不正确的答案?

不会,原因:TODO


整个代码的核心在于`枚举的顺序`,好的枚举的过程可以节省大量的时间

- 第一层,枚举是深度i,时间`O(n)`
- 第二层,当前深度的点的集合s1,
- 第三层,枚举前i-1层点集合,也就是s1的子集合s0
- 第四层,求出s1针对s0的补集sx
- 第五层,求出s0集合与sx集合之间边的最小和,时间`O(n)`

> ps,我写的这个枚举的顺序不好,因为要用到子集生成,应该要用到

> 下面考虑时间复杂度：
> 首先考虑我们枚举集合的数量： 我们集合的枚举量显然是全集的子集的子集个数和。乍一看全集有$2^n$个子集，每个子集有$2^n$个子集。那么个数是$O(4^n)$？事实上不是这样。考虑对于所有的的子集，他们的子集个数是$O(2^k)$个，其中k是子集的元素个数。那么对于大部分的子集，他们的元素个数k都不等于n。显然这个上界太松了。那么如何计算枚举量呢？考虑对于元素个数为x的子集，共有$C\_{n}^x$种方式。每个子集有$2^x$个子集，那么总的枚举量是$C\_{n}^x~\times~2^x$。应用二项式定理，原式＝$(2+1)^n$。所以子集的枚举量是$O(3^n)$。

> 对于每个集合最多有n个元素，每个元素枚举到它的边是$O(n)$的，所以这里的复杂度是$O(n^2)$的。

> 那么总的复杂度是$O(3^n~\times~n^2)$。大概是七千万左右。考虑对于绝大部分集合跑不满$n^2$的上界，并且可以进行一些剪枝优化，最终可以通过本题

> 来自: https://www.luogu.com.cn/blog/fusu2333/solution-p3959

相关知识

- [【高中数学基础课】二项式定理 - 知乎](https://zhuanlan.zhihu.com/p/37314812)
- [含有 n 个元素的集合的子集个数为 2ⁿ，求证明过程？ - 知乎](https://www.zhihu.com/question/32111634)

### 总结
我觉得这个题目的核心应该是2个预处理,大大节省了时间

1. `gs[s0]`,求s0集合出发能到达的点集,用来判断sx是否是合法的,这是一个剪枝
2. `dis[s][i]`,求点i到点集s的最小边长,使得在求s0,sx之间的最小边长和的时间从`n^2`降到`n`

## 代码

使用我写的库的代码

::: fold

```c
<%- include("1.cpp") %>
```

:::


完整的代码

::: fold

```c
<%- include("1_tran.cpp") %>
```
:::
