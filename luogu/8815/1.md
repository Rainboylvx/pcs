---
_id: "luogu-P8815"
title: "[CSP-J 2022] 逻辑表达式"
date: 2022-12-10 10:36
update: 2022-12-10 10:36
author: Rainboy
tags:
    - dfs
    - csp
    - "csp-j"
catalog: dfs
source: 
    - 
      oj: luogu
      url: https://www.luogu.com.cn/problem/P8815
---

@[toc]

## 题目



### 题目描述

逻辑表达式是计算机科学中的重要概念和工具，包含逻辑值、逻辑运算、逻辑运算优先级等内容。

在一个逻辑表达式中，元素的值只有两种可能：$0$（表示假）和 $1$（表示真）。元素之间有多种可能的逻辑运算，本题中只需考虑如下两种：“与”（符号为 `&`）和“或”（符号为 `|`）。其运算规则如下：

$0 \mathbin{\&} 0 = 0 \mathbin{\&} 1 = 1 \mathbin{\&} 0 = 0$，$1 \mathbin{\&} 1 = 1$；  
$0 \mathbin{|} 0 = 0$，$0 \mathbin{|} 1 = 1 \mathbin{|} 0 = 1 \mathbin{|} 1 = 1$。

在一个逻辑表达式中还可能有括号。规定在运算时，括号内的部分先运算；两种运算并列时，`&` 运算优先于 `|` 运算；同种运算并列时，从左向右运算。

比如，表达式 `0|1&0` 的运算顺序等同于 `0|(1&0)`；表达式 `0&1&0|1` 的运算顺序等同于 `((0&1)&0)|1`。

此外，在 C++ 等语言的有些编译器中，对逻辑表达式的计算会采用一种“短路”的策略：在形如 `a&b` 的逻辑表达式中，会先计算 `a` 部分的值，如果 $a = 0$，那么整个逻辑表达式的值就一定为 $0$，故无需再计算 `b` 部分的值；同理，在形如 `a|b` 的逻辑表达式中，会先计算 `a` 部分的值，如果 $a = 1$，那么整个逻辑表达式的值就一定为 $1$，无需再计算 `b` 部分的值。

现在给你一个逻辑表达式，你需要计算出它的值，并且统计出在计算过程中，两种类型的“短路”各出现了多少次。需要注意的是，如果某处“短路”包含在更外层被“短路”的部分内则不被统计，如表达式 `1|(0&1)` 中，尽管 `0&1` 是一处“短路”，但由于外层的 `1|(0&1)` 本身就是一处“短路”，无需再计算 `0&1` 部分的值，因此不应当把这里的 `0&1` 计入一处“短路”。



### 输入格式
输入共一行，一个非空字符串 $s$ 表示待计算的逻辑表达式。



### 输出格式

输出共两行，第一行输出一个字符 `0` 或 `1`，表示这个逻辑表达式的值；第二行输出两个非负整数，分别表示计算上述逻辑表达式的过程中，形如 `a&b` 和 `a|b` 的“短路”各出现了多少次。



### 样例

|----|----|
|输入 #1  |输出 #1  |
|```  |```  \
|0&(1|0)|(1|1|1&0)  |1  \
|  |1 2  \
|```  |  \
|   |```  |
|输入 #2  |输出 #2  |
|```  |```  \
|(0|1&0|1|1|(1|1))&(0&1&(1|0)|0|1|0)&0  |0  \
|  |2 3  \
|```  |  \
|   |```  |



### 说明/提示
**【样例解释 \#1】**

该逻辑表达式的计算过程如下，每一行的注释表示上一行计算的过程：

```plain
0&(1|0)|(1|1|1&0)
=(0&(1|0))|((1|1)|(1&0)) //用括号标明计算顺序
=0|((1|1)|(1&0))   //先计算最左侧的 &，是一次形如 a&b 的“短路”
=0|(1|(1&0))       //再计算中间的 |，是一次形如 a|b 的“短路”
=0|1               //再计算中间的 |，是一次形如 a|b 的“短路”
=1
```

**【样例 \#3】**

见附件中的 `expr/expr3.in` 与 `expr/expr3.ans`。

**【样例 \#4】**

见附件中的 `expr/expr4.in` 与 `expr/expr4.ans`。

**【数据范围】**

设 $\lvert s \rvert$ 为字符串 $s$ 的长度。

对于所有数据，$1 \le \lvert s \rvert \le {10}^6$。保证 $s$ 中仅含有字符 `0`、`1`、`&`、`|`、`(`、`)` 且是一个符合规范的逻辑表达式。保证输入字符串的开头、中间和结尾均无额外的空格。保证 $s$
中没有重复的括号嵌套（即没有形如 `((a))` 形式的子串，其中 `a` 是符合规范的逻辑表
达式）。

| 测试点编号 | $\lvert s \rvert \le$ | 特殊条件 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $3$ | 无 |
| $3 \sim 4$ | $5$ | 无 |
| $5$ | $2000$ | 1 |
| $6$ | $2000$ | 2 |
| $7$ | $2000$ | 3 |
| $8 \sim 10$ | $2000$ | 无 |
| $11 \sim 12$ | ${10}^6$ | 1 |
| $13 \sim 14$ | ${10}^6$ | 2 |
| $15 \sim 17$ | ${10}^6$ | 3 |
| $18 \sim 20$ | ${10}^6$ | 无 |

其中：  
特殊性质 1 为：保证 $s$ 中没有字符 `&`。  
特殊性质 2 为：保证 $s$ 中没有字符 `|`。  
特殊性质 3 为：保证 $s$ 中没有字符 `(` 和 `)`。

**【提示】**

以下给出一个“符合规范的逻辑表达式”的形式化定义：

- 字符串 `0` 和 `1` 是符合规范的；
- 如果字符串 `s` 是符合规范的，且 `s` 不是形如 `(t)` 的字符串（其中 `t` 是符合规范的），那么字符串 `(s)` 也是符合规范的；
- 如果字符串 `a` 和 `b` 均是符合规范的，那么字符串 `a&b`、`a|b` 均是符合规范的；
- 所有符合规范的逻辑表达式均可由以上方法生成。


## 解析

整个式子具有的特点

1. 有运算优先级
2. 有括号,先算括号,其实也可以说括号的优先级最高


```

原始表达式
1. 0&(1|0)|(1|1|1&0)

0 & ( 1  |  0 ) |  (  1  |  1  |  1  &  0   )


0

&

1 | 0

                    
0 & ( 1  |  0 ) |  [  (  1  |  1  |  1  &  0   ) ]
left  
(0&(1|0)) | ((1|1)|(1&0))


0 & (1 | 0 )

0 &  1 | 0 

0 | 1 & 0 


字符串-> token序列 -> 表达式树
运算符号具有优先级,设`|`的优先级是1,`&`的优先级是2
```


## 解析

这个题目的本质就是:**如何把字符串表达式转成表达式树**,这个过程一般如下

```
字符串表达式  --(分析/拆解)-> token序列 ---(处理)-->表达式树
```

## 原理说明

### 1. Q: 什么是表达式树

```plaintext
1&(1|0)&1&1
```
对应的表达式树为

```viz-dot
graph "1" {
  "0"[label ="1"];
  "1"[label ="&"];
  "2"[label ="1"];
  "3"[label ="|"];
  "4"[label ="0"];
  "5"[label ="&"];
  "6"[label ="1"];
  "7"[label ="&"];
  "8"[label ="1"];
    "7" -- "5";
    "7" -- "8";
    "5" -- "1";
    "5" -- "6";
    "1" -- "0";
    "3" -- "2";
    "3" -- "4";
    "1" -- "3";
}
```

```plaintext
(1|0)&1&1
```
对应为

```viz-dot
<%- include("images/2.dot") _%>
```

```plaintext
1|0&1&1
```
对应为

```viz-dot
<%- include("images/3.dot") _%>
```

### 2. Q: 如果利用表达式树计算数值呢?

你可以发现,**只要在表达式树上按先序遍历的顺序就可以求出表达式的值**

ps: 按中序遍历输出就是波兰表达式

### 3. Q: 如果得到token序列呢?

token代表的意思是表达式中不可再分割的单元

很简单,对于表达式 `1|0&1&1` 来说,每一个字符都是一个token

```
1 , | , & ,1 & , & ,1
```

token大概可以分成两类,数字`1,0`,运算符`&,|`,其中运算符有**优先级**,我们认为
- `|`的优先级为1
- `&`的优先级为2,高于`|`
- 其它运算符为`-1`,(一些虚拟的运算符,比如最后一个数字的后面,第一个数字的前面,括号)


### 4. Q: 通过token如何得到表达式树呢?

**核心思想**:


- 最小的表达式是单个0或1
- 每一个表达式,要么和前一个运算符结合,要么和后一个运算符号结合,根据前后运算符号的优先级决定当前表达式和哪个运算符结合
- `|`的优先级为1,`&`的优先级为2,其它的优先级都是-1

**一句话核心**,
每一层的递归的任务: 得到一个表达式,决定这个表达式是和前面的运算符结合(左结合)还是和后面的表达式结合(右结合)
每一个token都有自己的任务

例如

```plaintext
1|0
```

很容易得到下面的表达式树:

```viz-dot
<%- include("images/4.dot") _%>
```

- 先读取到1,这是一个表达式
- 1的前面没有运算符,认为前面的运算符优先级为-1,后面的运算符为`|`,后面的优先级高
  设1这个表达式为`pre_tree`(意思为前一个表达式树),所以1应该和后面的表达式结合
- 读取到`|`,它的左子树为`pre_tree`,也就是1,它的右子树为递归读取的后面的表达式
- 读取0,前面的是运算符`|`,后面的没有,所以前面的优先级高,直接返回0这个表达式
- 递归回到上一层,0做为`|`的左子树
- 形成这个表达式树

```plaintext
1|1&0
```
```viz-dot
<%- include("images/5.dot") _%>
```

```plaintext
1|1&0
  ^
  └─ 应该和后面的 &结合,因为高于前面的|


1|1&0
  ---
   ^
   └─ 整体形成一个表达式A,
      A前面的运算符为|,后面没有,前面的优先级高,A和前面结合

最终形成上面的表达式树
```

------------------

```plaintext
1|0&1&0
```

```viz-dot
<%- include("images/6.dot") _%>
```


这个自己想一想!

### 如何处理括号呢?

```plaintext
1&1&(1|0)
```

```viz-dot
<%- include("images/7.dot") _%>
```

**核心思想:**把括号内当成一个单独的表达式,它要么左结合,要么右结合.

具体怎么做?

- 读取到`(`时,完全不关心前面的运算符是什么,直接递归,当成从头读取表达式来做
- 读取到`)`时,则一定得到了一个表达式(括号内的),这个表达式是`pre_tree`
  现在要做的就是把`pre_tree`前后比较运算符号,决定和哪个结合


```plaintext
0&((1|0)&1)
```

```viz-dot
<%- include("images/8.dot") _%>
```

```plaintext
(1|1)&((1|0)&1)
```

```viz-dot
<%- include("images/9.dot") _%>
```
## 代码

- [graphviz.hpp 调试用,生成对应的表达式树的图片](./graphviz.hpp)
- 没有处理括号的代码,[t1.cpp](./t1.cpp)
- 增加了处理括号的代码,[t2.cpp](./t2.cpp)
- 对t2.cpp的优化,去除重复的代码,[t3.cpp](./t3.cpp)


最终代码

```cpp
<%- include("1.cpp") _%>
```
