---
_id: "luogu-P5318"
title: "【深基18.例3】查找文献"
date: 2020-05-06 21:12
update: 2020-05-06 21:12
author: Rainboy
tags:
    - 图的遍历
    - 入门
    - 图论
catalog: 图的遍历
source: 
    - 
      oj: luogu
      url: https://www.luogu.com.cn/problem/P5318
---

@[toc]

## 题目



### 题目描述

小K 喜欢翻看洛谷博客获取知识。每篇文章可能会有若干个（也有可能没有）参考文献的链接指向别的博客文章。小K 求知欲旺盛，如果他看了某篇文章，那么他一定会去看这篇文章的参考文献（如果他之前已经看过这篇参考文献的话就不用再看它了）。

假设洛谷博客里面一共有 $n(n\le10^5)$ 篇文章（编号为 1 到 $n$）以及 $m(m\le10^6)$ 条参考文献引用关系。目前小 K 已经打开了编号为 1 的一篇文章，请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。

这边是已经整理好的参考文献关系图，其中，文献 X → Y 表示文章 X 有参考文献 Y。保证编号为 1 的文章没有被其他文章引用。

![](https://cdn.luogu.com.cn/upload/image_hosting/f4n4tlhi.png)

请对这个图分别进行 DFS 和 BFS，并输出遍历结果。如果有很多篇文章可以参阅，请先看编号较小的那篇(因此你可能需要先排序)。







### 样例

|----|----|
|输入 #1  |输出 #1  |
|```  |```  \
|8 9  |1 2 5 6 3 7 8 4   \
|1 2  |1 2 3 4 5 6 7 8   \
|1 3  |```  \
|1 4  |   \
|2 5  |   \
|2 6  |   \
|3 7  |   \
|4 7  |   \
|4 8  |   \
|7 8  |   \
|```  |   |




## 解析

额，直接写

## 代码1

```c++
/* author: Rainboy email: rainboylvx@qq.com  time: 2022年 01月 16日 星期日 14:48:43 CST */
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e6+5,maxe = 1e6+5; //点与边的数量

int n,m;
/* 定义全局变量 */

struct linkList {
    typedef struct {int u,v,w,next;} edge;
    edge e[maxe];
    int h[maxn],edge_cnt=0;
    linkList(){	//构造函数
        edge_cnt=0;
        memset(h,-1,sizeof(h));
    }
    //遍历点u 周围点
    template<typename U>
    void for_each(int u,U func){
        for(int i = h[u] ; i !=-1;i = e[i].next)
            func(e[i].u,e[i].v,e[i].w); //u v w
    }
    void add(int u,int v,int w=0){
        e[edge_cnt] = {u,v,w,h[u]};
        h[u] = edge_cnt++;
    }
    void add2(int u,int v,int w=0){
        add(u,v,w);
        add(v,u,w);
    }
    edge& operator[](int i){
        return e[i];
    }
} e;

vector<pair<int,int>> v1;

bool vis[maxn];
void dfs(int u){
    vis[u] = 1;
    printf("%d ",u);
    int i;
    for(i=e.h[u];~i;i=e[i].next){
        int &v = e[i].v, &w = e[i].w;
        if( vis[v] == 0)
            dfs(v);
    }
}

void bfs(int u){
    queue<int> q;
    vis[u] = 1;
    q.push(u);
    while ( !q.empty() ) {
        int u = q.front();
        q.pop();
        printf("%d ",u);
        int i;
        for(i=e.h[u];~i;i=e[i].next){
            int &v = e[i].v, &w = e[i].w;
            if(vis[v] == 0){
                vis[v] = 1;
                q.push(v);
            }
        }
    }
}

int main(int argc,char * argv[]){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i){
        int u,v;
        scanf("%d%d",&u,&v);
        //v1.emplace_back(u,v);
        v1.push_back(std::make_pair(u,v));
    }
    sort(v1.begin(),v1.end());
    //std::reverse(v1.begin(), v1.end());
    //for (const auto& ee : v1) {
        //e.add(ee.first,ee.second);
    //}
    for(int i = v1.size()-1; i>=0;i--){
        e.add(v1[i].first, v1[i].second);
    }
    dfs(1);
    printf("\n");
    memset(vis,0,sizeof(vis));
    bfs(1);
    return 0;

}
```

## 代码2

```c
<%- include("1.cpp") %>
```
