---
_id: "luogu-P2672"
title: "[NOIP2015 普及组] 推销员"
date: 2023-07-27 22:15
update: 2023-07-27 22:15
author: Rainboy
tags:
    - 贪心
    - 找规律
    - 线段树
    - 树状数组
source: 
    - 
      oj: luogu
      url: https://www.luogu.com.cn/problem/P2672
---

@[toc]

## 题目

### 题目背景 
NOIP2015 普及组 T4



### 题目描述

阿明是一名推销员，他奉命到螺丝街推销他们公司的产品。螺丝街是一条死胡同，出口与入口是同一个，街道的一侧是围墙，另一侧是住户。螺丝街一共有 $N$ 家住户，第 $i$ 家住户到入口的距离为 $S_i$ 米。由于同一栋房子里可以有多家住户，所以可能有多家住户与入口的距离相等。阿明会从入口进入，依次向螺丝街的 $X$ 家住户推销产品，然后再原路走出去。

阿明每走 $1$ 米就会积累 $1$ 点疲劳值，向第 $i$ 家住户推销产品会积累 $A_i$ 点疲劳值。阿明是工作狂，他想知道，对于不同的 $X$，在不走多余的路的前提下，他最多可以积累多少点疲劳值。




### 输入格式
第一行有一个正整数 $N$，表示螺丝街住户的数量。

接下来的一行有 $N$ 个正整数，其中第 $i$ 个整数 $S_i$ 表示第 $i$ 家住户到入口的距离。数据保证 $S_1 \le S_2 \le \cdots \le S_n <10^8$。

接下来的一行有 $N$ 个正整数，其中第 $i$ 个整数 $A_i$ 表示向第 $i$ 户住户推销产品会积累的疲劳值。数据保证 $A_i<1000$。




### 输出格式

输出 $N$ 行，每行一个正整数，第 $i$ 行整数表示当 $X=i$ 时，阿明最多积累的疲劳值。




### 样例



输入/输出 # 1

::: line
```
5
1 2 3 4 5
1 2 3 4 5
```

```
15
19
22
24
25
```
:::

输入/输出 # 2

::: line
```
5
1 2 2 4 5
5 4 3 4 1
```

```
12
17
21
24
27
```
:::





### 说明/提示
### 输入输出样例 1 说明

$X=1$：向住户 $5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5$，总疲劳值为 $15$。

$X=2$：向住户 $4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $4+5$，总疲劳值为 $5+5+4+5=19$。

$X=3$：向住户 $3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $3+4+5$，总疲劳值为 $5+5+3+4+5=22$。

$X=4$：向住户 $2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $2+3+4+5$，总疲劳值 $5+5+2+3+4+5=24$。

$X=5$：向住户 $1,2,3,4,5$ 推销，往返走路的疲劳值为 $5+5$，推销的疲劳值 $1+2+3+4+5$，总疲劳值 $5+5+1+2+3+4+5=25$。


### 输入输出样例2说明

$X=1$：向住户 $4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $4$，总疲劳值 $4+4+4=12$。

$X=2$：向住户 $1,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4$，总疲劳值 $4+4+5+4=17$。

$X=3$：向住户 $1,2,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4+4$，总疲劳值 $4+4+5+4+4=21$。

$X=4$：向住户 $1,2,3,4$ 推销，往返走路的疲劳值为 $4+4$，推销的疲劳值为 $5+4+3+4$，总疲劳值 $4+4+5+4+3+4=24$。或者向住户 $1,2,4,5$推销，往返走路的疲劳值为 $5+5$，推销的疲劳值为 $5+4+4+1$，总疲劳值 $5+5+5+4+4+1=24$。

$X=5$：向住户$1,2,3,4,5$推销，往返走路的疲劳值为$5+5$，推销的疲劳值为$5+4+3+4+1$，总疲劳值$5+5+5+4+3+4+1=27$。

### 数据说明

对于 $20\%$ 的数据，$1 \le N \le20$；  
对于 $40\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1 \le N \le 1000$；  
对于 $100\%$ 的数据，$1 \le N \le 100000$。



## 解析

根据数据规模,显然存在一个`o(n)`的算法,可以求解这个问,也就是说必然存在`某种规律`,才可以达成这个时间度

根据观察我写的暴力程序,发现每一次选的数都是在前面已经选的数的基础上,再选一个数,关键就是于,再选哪个数!


## 暴力程序 的代码

::: fold
```c
<%- include("1_1.cpp") %>
```
:::

::: fold
```c
<%- include("1_2.cpp") %>
```
:::

## 通过的代码

注意: 下面的代码是使用 bit(树状数组)求区间最大值,比较复杂,建议使用线段树来求区间最大值

::: fold
```
<%- include("2.cpp") _%>
```
:::

::: fold
```
<%- include("2_tran.cpp") _%>
```
:::
