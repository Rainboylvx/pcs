---
_id: "luogu-P1311"
title: "选择客栈"
date: 2020-08-12 17:27
update: 2020-08-12 17:27
author: Rainboy
tags:
    - 递推
source: 
    - 
      oj: luogu
      url: https://www.luogu.com.cn/problem/P1311
---

@[toc]

## 题目



### 题目描述

丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。

两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。

他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。



### 输入格式
共 $n+1$ 行。

第一行三个整数 $n, k, p$，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值；

接下来的 $n$ 行，第 $i+1$ 行两个整数，之间用一个空格隔开，分别表示 $i $ 号客栈的装饰色调 $a_i$ 和 $i$ 号客栈的咖啡店的最低消费 $b_i$。



### 输出格式

一个整数，表示可选的住宿方案的总数。




### 样例

|----|----|
|输入 #1  |输出 #1  |
|```  |```  \
|5 2 3   |3  \
|0 5   |  \
|1 3   |```  \
|0 2   |   \
|1 4   |   \
|1 5   |   \
|  |   \
|```  |   |



### 说明/提示
### 样例解释

![](https://cdn.luogu.com.cn/upload/pic/101.png) 

2 人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤，但是若选择住 $4,5$号客栈的话，$4,5$ 号客栈之间的咖啡店的最低消费是 $4$ ，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。

### 数据范围

- 对于 $30\% $ 的数据，有 $n \leq 100$ ；
- 对于 $50\% $ 的数据，有 $n \leq 1\,000$；
- 对于 $100\%$ 的数据，有 $2 \leq n \leq 2 \times 10^5$，$1 \leq k
 \leq 50$，$0 \leq p \leq 100$，$0 \leq b_i \leq 100$。

## 解析

那这样的话,时间复杂度为$O(n^2)$,要想办法优化

浪费的时间主要在于找$1 \rightarrow x$之间的查找同颜色的操作上,那只要把这个信息记录下来,类似前缀和的思想不就ok了.

复杂度为$O(n \times k)$,可以接受

使用二分的代码,时间为`O(nlogn)`

## 代码3

注: 代码未完成

```cpp
<%- include("2.cpp") _%>
```

## 代码2

不使用使用二分的代码,时间为`O(n)`

```c
/*-----------------
* author: Rainboy
* email: rainboylvx@qq.com
* time: 2019年 05月 09日 星期四 14:56:01 CST
* problem: noip2011-day1t2
*----------------*/
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int n,k,p;

int f[200005]; //f[i] 1->i-1之间的最后一个小于p的数字的位置,包括自己
int c[200005][55]; //c[i][k] 表示第i个数之前某种颜色的数量,包括i

int ans = 0;

void init(){
    scanf("%d%d%d",&n,&k,&p);
    int t1,t2;
    int i;
    for (i=1;i<=n;i++){
        scanf("%d%d",&t1,&t2);
        memcpy(c[i],c[i-1],sizeof(c[0]));

        c[i][t1]++;

        if( t2 <= p)
            f[i] = i;
        else
            f[i] = f[i-1];
        /* dp */
        int pre = f[i]; // 得到第i个元素之前第一个<=p的位置
        if(pre == i) // 如果包含了自己,要把自己给去掉,因为自己不能和自己配对
            pre--;
        ans += c[pre][t1]; // 加上pre位置之前t1这个颜色出现的次数
    }
}

int main(){
    init();
    printf("%d\n",ans);
    return 0;
}
```

