---
_id: "luogu-P5019"
title: "[NOIP2018 提高组] 铺设道路"
date: 2023-08-01 16:05
update: 2023-08-01 16:05
author: Rainboy
tags:
    - 
source: 
    - 
      oj: luogu-P5019
      url: https://www.luogu.com.cn/problem/P5019
---

@[toc]

## 题目

### 题目背景 
NOIP2018 提高组 D1T1



### 题目描述

春春是一名道路工程师，负责铺设一条长度为 $n$ 的道路。 

铺设道路的主要工作是填平下陷的地表。整段道路可以看作是 $n$ 块首尾相连的区域，一开始，第 $i$ 块区域下陷的深度为 $d_i$ 。 

春春每天可以选择一段连续区间 $[L,R]$ ，填充这段区间中的每块区域，让其下陷深度减少 $1$。在选择区间时，需要保证，区间内的每块区域在填充前下陷深度均不为 $0$ 。 

春春希望你能帮他设计一种方案，可以在最短的时间内将整段道路的下陷深度都变为 $0$ 。 



### 输入格式
输入文件包含两行，第一行包含一个整数 $n$，表示道路的长度。 第二行包含 $n$ 个整数，相邻两数间用一个空格隔开，第 $i$ 个整数为 $d_i$ 。 



### 输出格式

输出文件仅包含一个整数，即最少需要多少天才能完成任务。 



### 样例



输入/输出 # 1

::: line
```
6   
4 3 2 5 3 5 

```

```
9
```
:::





### 说明/提示
【样例解释】

一种可行的最佳方案是，依次选择： 
$[1,6]$、$[1,6]$、$[1,2]$、$[1,1]$、$[4,6]$、$[4,4]$、$[4,4]$、$[6,6]$、$[6,6]$。   

【数据规模与约定】

对于 $30\%$ 的数据，$1 ≤ n ≤ 10$ ；    
对于 $70\%$ 的数据，$1 ≤ n ≤ 1000$ ；     
对于 $100\%$ 的数据，$1 ≤ n ≤ 100000 , 0 ≤ d_i ≤ 10000$ 。   



## NOIP2018 Day1 T1 道路铺设 题目解析

这个题目和以前一个题目 `积木大厦` 一样

## 30%得分的解析

对于30%的数据`1 ≤ 𝑛 ≤ 10`,n非常的小,那么可以用搜索的方法解决问题

遍历整个数组,找到最小的不但不为0的数,记它的位置为pos,然后从pos向左找单调增的区间a,向右找单调增加的区间b,a和b合并的区间就是要修改的区间,修改的次数为$a[pos]$.

不停的按上面的方式查找,直到所有的数字为0,时间复杂度大概为$n^3$

## 70%得分的解析

由题目可以知道:每个数字有一个**修改区间**:数的左右两边的增区间

![18d1t1-1.png](https://i.loli.net/2018/12/21/5c1c7626789a7.png)

所以我们可以先记录每个数字的位置,求出每个数字所在的**修改区间**,然后排序,依次进行区间修改

设$fl[i]$表示第$i$个位置的数字的修改区间的左值:

$$fl[i] = fl[i-1],a[i-1] >= a[i]$$
$$fl[i] = 1,a[i-1] < a[i]$$

同理我们可以求出$fr[i]$,合并之后,就可以知道i的**修改区间的大小**,时间复杂度$n^2$


## 100%得分的解析

```
对于100%的数据，1 ≤ 𝑛 ≤ 100000，0 ≤ di ≤ 10000 
```

10万的数据不可能使用$n^2$的算法,根据做题目的经验,这个题目很可能**存在特别的规律**,然后按个这个规律来做,可以降低复杂度.


类型1:如果数组的值是单调上升的,这个时间的天数就是最大值.

![18d1t1-2.png](https://i.loli.net/2018/12/21/5c1c7626899f3.png)

类型2:如果数组的值是一边是单调上升的,一边是单调下降的,这个时间的天数就是也还是最大值.因为:**你把左边上升的区间内的挖完的时间内,也就能把右边区间也能挖完!**

![18d1t1-3.png](https://i.loli.net/2018/12/21/5c1c7626919ba.png)

类型3:多个上升下降区间的组合
![18d1t1-4.png](https://i.loli.net/2018/12/21/5c1c76269e436.png)

![18d1t1-5 .png](https://i.loli.net/2018/12/21/5c1c76267d9fd.png)

先挖最低点,挖完后,就会分成多个不连续的区间,每个区间就要分别的计算时间,每个区间的计算方式就是上升的那个区间的相邻数字的差值和.

类型4:如果第一个区间是下降的呢?

我们可以认为存在第0个数据,这个道路是平的,这样就可以保证第一个区间一定上升的.

![18d1t1-6.png](https://i.loli.net/2018/12/21/5c1c76266b94b.png)

综上所述,具体做法为:添加一个虚拟0点,每个点i都和前一个点i-1比较,如果a[i-1] > a[i] 不计算,如果$a[i-1] <a[i]$,那么$ans += (a[i]- a[i-1])$


### 更简单和抽象的想法,DP解法

设$f[i]$表示处理完前$i$个坑所需的最小天数,考虑:$a[i+1]$,

- 如果$a[i] > a[i+1]$,$i+1$在一个下降的序列中,那么第$i+1$个坑一定可以在$f[i]$天中完成
- 如果$a[i] < a[i+1]$,$i+1$在一个上升的序列中,那么第$i+1$个坑还需要$a[i+1]-a[i]$天时间

状态转移为:

$$f[i] = f[i-1] + a[i]-a[i-1],a[i] > a[i-1]$$

## 代码

```c
#include <iostream>
 
using namespace std;
const int maxn=1e5+5;
int a[maxn];
int main(){
    int n;
    cin>>n;
    int lst=0;
    int ans=0;
    for(int i=0;i<n;i++){ //边读取边做
        int now;
        cin>>now;
        if(now>lst)
            ans+=now-lst;
        lst=now;
    }
    cout<<ans<<endl;
    return 0;
}
```
