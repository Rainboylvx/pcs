---
_id: "acwing-100"
title: "100. 增减序列"
date: 2023-07-05 10:33
update: 2023-07-05 10:33
author: Rainboy
tags: 
    - 差分
source: 
    - 
      oj: acwing
      url: "https://www.acwing.com/problem/content/description/103/"
---

## 解析


题目大意: 对一个序列就行区间加减1,问最少多少次所的数都一样.
第二问: 最终的序列有多少种.

区间加减转成,差分,单点操作

显然需要在差分数组上,修改成,除第一个元素个所有的全为0,因为0表示和前面的数一样.

但每一次要修改两个点,一个加1,一个减1

此时,完全只需要考虑点就可以了,且第一个点可以认为不存在

显然最好的情况是,一次修改两个点,当然这两个点要一正一负
修改的次数为`min(abs(a),abs(b))`,如果把一个点修改为0,就不可以双点修改了


剩下(全正或全负)的只能单点修改了(每一次修改第一个元素和这个元素,也相当于两个点)
修改的次数为`abs(sum)`

设s1为除了第一个元素的所有的正值的和,s2为负和的
答案为 `min(|s1|,|s2|) + | |s1| - |s2||`


如何求问题2: 最终极得到的序列可能有多少种


因为操作到最后,只有a1有值,`a2 ~ an`都是0,所以整个序列每个元素的值都是a1

那有多少种a1,那答案就有多少个

当`a2~an`的所有值都是正或负的时候,才可能操作a1

如果要对区间`i~n`,修改就是修改`ai,an+1`两个数,也就是说,修改`a1,ai`和`ai,an+1`
都可以使用ai变成0,且an+1,不会参与最后的计算,

那a1共有`abs(|s1| - |s2|) +1` 种可能性

## 代码

```c
<%- include("2.cpp") %>
```
