---
_id: 'noip-junior-2013-t1'
title: 转圈游戏
date: 2019-07-01 09:12
update: 2019-07-01 09:12
author: Rainboy
---

## 解析

核心是要找到规律,那么我找的规律如下:

```
问：经过多少轮，回到起点？

1. 得出一个公式一算第x个位置到达位置

0 -> m
1 -> m+1
x -> m+x
..
n-m-> m+n-m = n ->0
n-m+1 -> m+n-m+1 -> n-1


x -> （m+x) % n  1 位置

(2*m+x) % n

(m+x)%n -> 1. m+x , m+x <n
	   2. m+x-k*n m+x >=n
	   
x经过多少轮又回到x？

两种验证：
1 数学验证 -> (k*m+x) % n == x 部k是多少？

 k=n
 n*m % n ==0
	--> k*m % n ==0
	求m 与 n的最小公倍数
	m*n / gcd(m*n)
2. 写代码验证,显然写代码验证是比较好的，正好可以解决80%的代码

```

## 代码

```c
/*-----------------
* author: Rainboy
* email: rainboylvx@qq.com
* time: 2019年 05月 28日 星期二 14:35:02 CST
* problem: luogu-1965
*----------------*/
#include <bits/stdc++.h>
using namespace std;

int _n,m,k,x;

/* 快速幂 */
typedef long long LL;

/* 求 a^n */
LL _pow(LL a,LL n){
	LL base = a;
	LL ret =1;

	for(; n ; n = n >> 1){
		if(n & 1)//取最低位, 是不是很像判断奇偶
			ret = ret * base % _n ; //是1就乘
		base = base*base % _n;     //base增增
	}

	return ret;
}

int main(){
    scanf("%d%d%d%d",&_n,&m,&k,&x);
    int i;
    long long r = _pow(10,k);
    int base = 0;
    for(i=1;i<=r;i++){
        base = (base + _n-m) % _n;
    }
    for(i=0;i<_n;i++){
        int t = (base + i) %_n;
        if( t == x){
            printf("%d",i);
            return 0;
        }
    }
    return 0;
}
```


