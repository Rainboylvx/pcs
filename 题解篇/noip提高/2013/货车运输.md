---
title: 货车运输
date: 2019-06-30 17:30
update: 2019-06-30 17:30
author: Rainboy
---

## 解析

最大生成树+树链剖分+线段树

## 代码

```c
/*-----------------
* author: Rainboy
* email: rainboylvx@qq.com
* time: 2019年 06月 30日 星期日 16:04:25 GMT
* problem: luogu-p1967
*----------------*/
#include <bits/stdc++.h>
using namespace std;

#define maxn 100005
#define maxm 500005

int n,m,q;

int fa_bcj[maxn];
int son[maxn], top[maxn], dep[maxn], fa[maxn], size[maxn];

int color[maxn] = {0}; //点是否dfs1,dfs2过

inline void slpf_init() { //初始化
    memset(son,-1,sizeof(son));
}


/* ================= 向量星 =================*/
int head[maxn];
int edge_cnt = 0;
struct _e{
    int u,w,v,next;
    bool operator<(const _e x){
        return w > x.w;
    }
}e[maxm],e2[maxn];


void inline xlx_init(){
    edge_cnt = 0;
    memset(head,-1,sizeof(head));
}

void addEdge(int u,int v,int w){
    edge_cnt++;
    e[edge_cnt].u = u;
    e[edge_cnt].v= v;
    e[edge_cnt].w= w;
    e[edge_cnt].next = head[u];
    head[u] = edge_cnt;
}
/* ================= 向量星 end =================*/


void init(){
    xlx_init();
    slpf_init();
    scanf("%d%d",&n,&m);
    int i,j;
    int x,y,z;
    for (i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&z);
        e2[i].u = x;
        e2[i].v = y;
        e2[i].w = z;
    }
    scanf("%d",&q);
}




/* =====  树链剖分 ====*/

// dfs1 求 son[maxn], dep[maxn], fa[maxn], size[maxn];
int edge_pointer_old[maxn];
void dfs1(int u,int pre,int d,int w){
    color[u] = 1;
    dep[u] = d;
    fa[u] = pre;
    size[u] = 1;
    edge_pointer_old[u] = w;
    int i;
    for(i=head[u];i!=-1;i=e[i].next){
        int v = e[i].v;
        if( v == pre) continue;
        dfs1(v,u,d+1,e[i].w);
        size[u] += size[v];
        if(son[u] == -1 || size[v] > size[ son[u] ])
            son[u] = v;
    }
}

int new_idx = 0;
int old_new[maxn];
int new_old[maxn];
int edge_pointer_idx[maxn];

// dfs2 连重边为重链,求 top[maxn]
void dfs2(int u,int sf){
    top[u] = sf;
    old_new[u] = ++new_idx;
    new_old[new_idx] =  u;
    edge_pointer_idx[new_idx] = edge_pointer_old[u];
    if(son[u] != -1)
        dfs2(son[u],sf);
    else
        return ;
    int i;

    for(i=head[u];i!=-1;i=e[i].next){
        int v = e[i].v;
        if( v!= son[u] && v != fa[u])
            dfs2(v,v);
    }
}



/* =====  树链剖分 end ====*/

/* ================= 并查集 =================*/

inline void bcj_init(int x){ //并查集 初始化
    int i;
    for(i=1;i<=x;i++) fa_bcj[i] = i;
}
int find(int x){ //查找 and 压缩
    if( x == fa_bcj[x]) return x;
    fa_bcj[x] = find(fa_bcj[x]);
    return fa_bcj[x];
}

void bcj_union(int x,int y){
    int fx = find(x);
    int fy = find(y);
    fa_bcj[fx] = fy;
}
/* ================= 并查集 end =================*/

//============== kruskal算法
void kruskal(){
    int ans = 0;
    int i,j;
    int k=0 ;
    bcj_init(n);
    for(i=1;i<=m;i++){
        int f1 = find(e2[i].u);
        int f2 = find(e2[i].v);
        if( f1 != f2){
            addEdge(e2[i].u, e2[i].v, e2[i].w);
            addEdge(e2[i].v, e2[i].u, e2[i].w);
            fa_bcj[f1] = f2;
            k++;
            if( k == n-1) break; //选n-1条边
        }
    }
}
//============== kruskal算法 END



/* =====  线段树区间更新--lazy [区间加,区间求和] ====*/

/* 区间最值 的线段树 */
int st[maxn<<2]={0};    //线段树


inline int lson(int rt ){ return rt<<1;}
inline int rson(int rt ){ return (rt<<1)|1;}
/* 更新父亲 */
void pushup(int rt){
    st[rt] = min(st[lson(rt)] , st[rson(rt)]);
}

/* 单点更新*/
void update(int pos,int val,int l,int r,int rt){
    if(l == r){
        st[rt] = val;
    }
    int m = (l+r)>>1;
    if( pos <= m) update(pos,val,l,m,lson(rt));
    else update(pos,val,m+1,r,rson(rt));
    pushup(rt);
}

/* 区间查询 */
int query(int l1,int r1,int l,int r,int rt){
    if(l1<=l && r <= r1){//包含
        return st[rt];
    }

    int ret = 0x7f7f7f7f;
    int m = (l+r)>>1;
    if(l1 <= m) ret=min(ret, query(l1,r1,l,m,lson(rt)));
    if(r1 > m ) ret=min(ret, query(l1,r1,m+1,r,rson(rt)));
    return ret;
}

/* 建立线段树 */
void build(int l,int r,int rt){
    if( l==r){
        st[rt] = edge_pointer_idx[l];
        return ;
    }
    int m = (l+r)>>1;
    build(l,m,lson(rt));
    build(m+1,r,rson(rt));
    pushup(rt);
}

/* ====== 线段树区间更新--lazy-- END ====*/

//跨链,找到lca(x,y)
int lca_find(int x,int y){
    //找到两个点的重链的顶端点
    int ret = 0x7f7f7f7f;
    int f1 = top[x],f2 = top[y];
    int tmp = 0;
    while(f1 != f2){

        //从深度较深的点 向上爬
        if( dep[f1] < dep[f2]){
            swap(f1,f2);
            swap(x,y);
        }
        //交换后 y所在重链的 dep[ top[y] ] < dep[ top[x] ]
        //x top[x] 较深

        //跨链
        ret = min(ret,query(old_new[f1],old_new[x], 1, n,1 ));
        x =  fa[f1];
        f1 = top[x];
    }

    //返回较浅的那个点
    if( dep[x] > dep[y])
        swap(x,y);
    if( x != y){
        ret = min(ret,query(old_new[son[x]], old_new[y], 1, n,1));
    }
    return ret;
}

int main(){
    init();
    sort(e2+1,e2+1+m);
    kruskal();
    int i;
    for (i=1;i<=n;i++){
        if( color[i]) continue;
        dfs1(i,i,1,0);
        dfs2(i,i);
    }

    /* 线段树初始化 */
    build(1,n,1);
    int a,b;
    for (i=1;i<=q;i++){
        scanf("%d%d",&a,&b);
        if(find(a) != find(b))
            printf("%d\n",-1);
        else{
            int ans = lca_find(a, b);
            printf("%d\n",ans);
        }
    }
    return 0;
}
```
## 代码2

树上倍增

```cpp
<%- include("./luogu_p1967.cpp") _%>
```
