---
_id : 'noip-junior-2013-t2'
title: 火柴排队
date: 2019-07-01 09:14
update: 2019-07-01 09:14
author: Rainboy
---


## 解析

利用数学证明:上下两个序列最大值和最大值对应,最小值与最小值对应,其它也按大小的顺序一一对应的时间,所求的值是最小的.

保持第一个序列不要动,那第二个序列每个值都要有一个相应的目标位置.

例如,对于下面的样例来说.

```plaintext
4
1 3 4 2
1 7 2 4
```

第二个序列的

```plaintext
1 7 2 4  原值
1 2 3 4  下标
1 3 4 2  目标位置
```

我们发现,就是让目标位置变成从小到大排序.根据要求,只能相邻的两个值交换,那不就是**冒泡排序**?冒泡排序要交换几次?不就是求逆序对?所以要选用$nlog(n)$的树状数组来求.


```
结果需要对 99,999,997
那很说明真正的交换次数大

肯定是一边算一边取余

答案不是通过**模拟**统得出来的


根据做题目的经验：

交换次数 == 逆序对数量 ？

step1:

高度差最小，显然，最大对最对，最小对最小，**应该保持一个序列不动，只动别一个序列**,那然后第二个序列的每个数都应该有一个位置

4
2 3 1 4
3 2 1 4->4应该在4号位,3应该在2号位置,2应该在1,1应该在3
-------

3 2 1 4
对应下面
2 1 3 4


4
1 3 4 2
1 7 2 4


1 7 2 4
对应下面
1 3 4 2

那交换次数呢? 只能相邻交换,那就是**冒泡排序**啊

1 3 4 2

第一趟

1 3 2 4 交换一次
1 2 3 4 交换1次

总交换次数就是冒泡排序总交换的次数:  60%的分

又因为冒泡排序可以求**逆序对**
2 1 一个逆序对
3 2 1 三个对

100 1 2 3 4 5  5 5个对

所以 得出 逆序对的数量就是交换次数,用BIT求, nlogn 100%
```

## 代码

```c
/*-----------------
* author: Rainboy
* email: rainboylvx@qq.com
* time: 2019年 05月 27日 星期一 08:17:58 CST
* problem: luogu-1966
*----------------*/
#include <bits/stdc++.h>
using namespace std;

#define maxn 100005
int n;
struct _p {
    int idx,val;
};

struct _px {
    int oidx,nidx,val;
};

bool cmp1(_p &a,_p &b){
    return a.val < b.val;
}

bool cmp2(_px &a,_px &b){
    return a.val< b.val;
}

bool cmp3(_px &a,_px &b){
    return a.oidx< b.oidx;
}


_p a[maxn];
_px b[maxn];
int c[maxn]; //对应的序列
int d[maxn];

void init(){
    scanf("%d",&n);
    int i;
    for (i=1;i<=n;i++){
        scanf("%d",&a[i].val);
        a[i].idx =i;
    }
    sort(a+1,a+n+1,cmp1);
    for (i=1;i<=n;i++){
        scanf("%d",&b[i].val);
        b[i].oidx = i;
    }
    sort(b+1,b+n+1,cmp2);
    for (i=1;i<=n;i++){
        b[i].nidx = i;
    }
    sort(b+1,b+n+1,cmp3);
    for (i=1;i<=n;i++){
        //printf("%d %d\n",b[i].val,b[i].nidx);
        d[i] = a[b[i].nidx].idx;
        //printf("%d\n",c[i]);
    }

}


int lowbit(int x){
    return x &-x;
}


void update(int pos,int val){
    while(pos <=n){
        c[pos] += val;
        pos += lowbit(pos);
    }
}

int query(int pos){
    int sum = 0;
    while( pos > 0){
        sum += c[pos];
        pos -= lowbit(pos);
    }
    return sum;
}


void deal(){
    int i;
    int ans = 0;
    for (i=1;i<=n;i++){
        update(d[i],1);
        ans = (ans + i-query(d[i])) % 99999997;
    }

    printf("%d\n",ans);
}
int main(){
    init();
    deal();
    return 0;
}
```

