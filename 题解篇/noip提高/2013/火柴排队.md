---
title: 火柴排队
date: 2019-07-01 09:14
update: 2019-07-01 09:14
author: Rainboy
---


## 解析

利用数学证明:上下两个序列最大值和最大值对应,最小值与最小值对应,其它也按大小的顺序一一对应的时间,所求的值是最小的.

保持第一个序列不要动,那第二个序列每个值都要有一个相应的目标位置.

例如,对于下面的样例来说.

```plaintext
4
1 3 4 2
1 7 2 4
```

第二个序列的

```plaintext
1 7 2 4  原值
1 2 3 4  下标
1 3 4 2  目标位置
```

我们发现,就是让目标位置变成从小到大排序.根据要求,只能相邻的两个值交换,那不就是**冒泡排序**?冒泡排序要交换几次?不就是求逆序对?所以要选用$nlog(n)$的树状数组来求.

## 代码

```c
/*-----------------
* author: Rainboy
* email: rainboylvx@qq.com
* time: 2019年 05月 27日 星期一 08:17:58 CST
* problem: luogu-1966
*----------------*/
#include <bits/stdc++.h>
using namespace std;

#define maxn 100005
int n;
struct _p {
    int idx,val;
};

struct _px {
    int oidx,nidx,val;
};

bool cmp1(_p &a,_p &b){
    return a.val < b.val;
}

bool cmp2(_px &a,_px &b){
    return a.val< b.val;
}

bool cmp3(_px &a,_px &b){
    return a.oidx< b.oidx;
}


_p a[maxn];
_px b[maxn];
int c[maxn]; //对应的序列
int d[maxn];

void init(){
    scanf("%d",&n);
    int i;
    for (i=1;i<=n;i++){
        scanf("%d",&a[i].val);
        a[i].idx =i;
    }
    sort(a+1,a+n+1,cmp1);
    for (i=1;i<=n;i++){
        scanf("%d",&b[i].val);
        b[i].oidx = i;
    }
    sort(b+1,b+n+1,cmp2);
    for (i=1;i<=n;i++){
        b[i].nidx = i;
    }
    sort(b+1,b+n+1,cmp3);
    for (i=1;i<=n;i++){
        //printf("%d %d\n",b[i].val,b[i].nidx);
        d[i] = a[b[i].nidx].idx;
        //printf("%d\n",c[i]);
    }

}


int lowbit(int x){
    return x &-x;
}


void update(int pos,int val){
    while(pos <=n){
        c[pos] += val;
        pos += lowbit(pos);
    }
}

int query(int pos){
    int sum = 0;
    while( pos > 0){
        sum += c[pos];
        pos -= lowbit(pos);
    }
    return sum;
}


void deal(){
    int i;
    int ans = 0;
    for (i=1;i<=n;i++){
        update(d[i],1);
        ans = (ans + i-query(d[i])) % 99999997;
    }

    printf("%d\n",ans);
}
int main(){
    init();
    deal();
    return 0;
}
```

