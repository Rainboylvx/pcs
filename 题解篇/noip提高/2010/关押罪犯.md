---
title: 关押罪犯
date: 2019-07-02 13:20
update: 2019-07-02 13:20
author: Rainboy
---

## 解析

### 方法一:

很容易就想到类似$Kruskal$算法的思想:把每条边从大到小排序,尽量不让大的边上的两个点在同一个集合内.

如何实现呢?

```plaintext
1 2 28351
3 4 12884
1 3 6618
2 3 3512
1 4 2534
2 4 1805
```

使用两个集合表示两个监狱.

不好的地方: $(1,2)$不应该的一起,$(3,4)$不应该的一起,但是不知道$(1,3)$是不是应该的一起?

```pl|intext
+----+              +----+
| 1  |              | 2  |
| 3  |              | 4  |
+----+              +----+
```

核心:使用多个集合,$K^'$表示不合点$k$在一起的点的集合.然后不停的合并集合,直到有冲突的时候,输出冲突的值.


**体会一下多个集合的作用**


### 方法二:

二分答案+二分图染色


## 代码

```c
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define maxn 20005
#define maxm 100005

int n,m;
int first[maxn];
int edge_cnt = 0;
struct _e{
    int u,v,w,next;
}e[maxm<<1];

/* ================= 并查集 =================*/
int fa[maxn <<1];

inline void bjj_init(int x){ //并查集 初始化
    int i;
    for(i=1;i<=x;i++) fa[i] = i;
}
int find(int x){ //查找 and 压缩
    if( x == fa[x]) return x;
    fa[x] = find(fa[x]);
    return fa[x];
}

void bjj_union(int x,int y){
    int fx = find(x);
    int fy = find(y);
    fa[fx] = fy;
}
/* ================= 并查集 end =================*/

/* 边集数组 */
struct _e_e{
    int u,v,w;
}e_e[maxm];
inline void push(int u,int v,int w,int cnt){
    e_e[cnt].u = u; e_e[cnt].w = w; e_e[cnt].v = v;
}

bool cmp(_e_e &a,_e_e &b){
    if(a.w > b.w)
        return true;
    return false;
}

void init(){
    int i;
    memset(first,-1,sizeof(first));
    scanf("%d%d",&n,&m);
    bjj_init(n<<1);

    for (i=1;i<=n;i++) fa[i] = i; //并查集 初始化

    int t1,t2,t3;
    for (i=1;i<=m;i++){     //读取边
        scanf("%d%d%d",&t1,&t2,&t3);
        push(t1,t2,t3,i);
    }
    //排序, 大到小
    sort(e_e+1,e_e+m+1,cmp);
}


int deal(){
    
    //从大到小
    int i;
    for(i=1;i<=m;i++){
        int &u = e_e[i].u;
        int &v = e_e[i].v;
        int fu = find(u);
        int fv = find(v);
        if(fv != fu){ //不在同一个集合中
            bjj_union(fv,n+u);
            bjj_union(fu,n+v);
        }
        else        //在同一个集合中
            return e_e[i].w;
    }
    return 0; 
}

int main(){
    init();
    int ans = deal();
    printf("%d",ans);
    return 0;
}
```

