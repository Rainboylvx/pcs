---
title: 选择客栈
date: 2019-07-07 09:52
update: 2019-07-07 09:52
author: Rainboy
---

## 解析

那这样的话,时间复杂度为$O(n^2)$,要想办法优化

浪费的时间主要在于找$1 \rightarrow x$之间的查找同颜色的操作上,那只要把这个信息记录下来,类似前缀和的思想不就ok了.

复杂度为$O(n \times k)$,可以接受

## 代码

```c
/*-----------------
* author: Rainboy
* email: rainboylvx@qq.com
* time: 2019年 05月 09日 星期四 14:56:01 CST
* problem: noip2011-day1t2
*----------------*/
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int n,k,p;

int f[200005]; //f[i] 1->i-1之间的最后一个小于p的数字的位置,包括自己
int c[200005][55]; //c[i][k] 表示第i个数之前某种颜色的数量,包括i

int ans = 0;

void init(){
    scanf("%d%d%d",&n,&k,&p);
    int t1,t2;
    int i;
    for (i=1;i<=n;i++){
        scanf("%d%d",&t1,&t2);
        memcpy(c[i],c[i-1],sizeof(c[0]));

        c[i][t1]++;

        if( t2 <= p)
            f[i] = i;
        else
            f[i] = f[i-1];
        /* dp */
        int pre = f[i]; // 得到第i个元素之前第一个<=p的位置
        if(pre == i) // 如果包含了自己,要把自己给去掉,因为自己不能和自己配对
            pre--;
        ans += c[pre][t1]; // 加上pre位置之前t1这个颜色出现的次数
    }
}

int main(){
    init();
    printf("%d\n",ans);
    return 0;
}
```

