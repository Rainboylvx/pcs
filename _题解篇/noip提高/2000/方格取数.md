---
_id: "noip2000-tg-t4"
title: "[noip2000 T4]方格取数"
date: 2019-04-02 17:35
update: 2019-04-02 17:35
author: Rainboy
---

## 解析

设两条路一起走,

设$f[i][j][k][l]$表示,当前A走到点A(i, j)，B走到点B(k, l),得到的最大得分

一共有4种可能来当前状态(i,j,k,l)的情况

![](https://ww1.sinaimg.cn/large/007i4MEmly1g1ofi9g9mej30de0dedg2.jpg)

如果$i == k,j==l$表示到达的点为一个点,那只要加一次分

**注意:**有些状态不需要计算,A,B同时向前走,那么$i+j == k+l$,只有满足这个条件的状态才计算

## 代码

```c
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;


int map[20][20] = {0};
int n;

int f[15][15][15][15]={0};

int fx[4][4] = {
    -1,0,-1,0,
    -1,0,0,-1,
    0,-1,0,-1,
    0,-1,-1,0
};

void init(){
    int t1,t2,t3;
    scanf("%d",&n);
    int i;
    for (i=1;1;i++){
        scanf("%d%d%d",&t1,&t2,&t3);
        if( t1== 0 && t2== 0&& t3== 0)
            break;
        map[t1][t2] = t3;
    }
}
int main(){
    init();
    /*dp  */
    //f[1][1][1][1] = map[1][1];

    int i;
    int x1,y1,x2,y2;
    for(x1=1;x1<=n;x1++)
        for(y1=1;y1<=n;y1++)
            for(x2=1;x2<=n;x2++)
                for(y2=1;y2<=n;y2++){

                    if(x1+y1 != x2+y2) //不对
                        continue;

                    if(x1 == x2 && y1 == y2){
                        for(i=0;i<=3;i++){
                            f[x1][y1][x2][y2] = max(
                                f[x1][y1][x2][y2],
                                f[x1 + fx[i][0]][y1 + fx[i][1]][x2 + fx[i][2]][y2 + fx[i][3]]+map[x1][y1]
                                );

                        }
                    }
                    else 
                        for(i=0;i<=3;i++){
                            f[x1][y1][x2][y2] = max(
                                f[x1][y1][x2][y2],
                                f[x1 + fx[i][0]][y1 + fx[i][1]][x2 + fx[i][2]][y2 + fx[i][3]]+map[x1][y1]+map[x2][y2]
                                );
                        }
                }
    printf("%d",f[n][n][n][n]);

    return 0;
}
```
