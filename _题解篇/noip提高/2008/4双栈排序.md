## 解析

### 1.如何判断是否可行

老办法面对题目的时候,先手动模拟一遍样例,有三个样例.

在模拟到第二个数据`2 3 4 1`发现,

$2,3$不能在同一个栈里,因为$2,3,1$.同样$3,4$不能在同一个栈里,因为$3,4,1$.同样$2,4$不能的同一个栈里.


**得出**:只要存在这样的三个数据:$i < j < k,p[k]< p[i] <p[j]$ 就不能让$p[i],p[j]$在同一个栈里.当然,最简单的想法就是用搜索(或其它方法)找这个序列里是否存在不止两个($>=3$)存在上面的关系,如果有,就是不能**双栈排序**.

想一想,$a,b$如果不能在同一个栈里,那么可以在两个栈里,如果有一个$c$,它和$a,b$都冲突,那就说明**不可能**了,这样描述把元素分成两个部分,同一个部分的元素不能有**联系**的数据结构,不就是**二分图**吗!所以就里用到的算法就是判断图是不是二分图:二分图染色算法.


$f[i]$表示$i+1,n$之中的最小值

$$f[i] = min\{f[i+1],a[i+1]\}$$

使用DP后,从$O(n^3)$降到$O(n^2)$



### 2.如何输出最小字典序

如果一个元素,它如果能在栈1,那它就应该在栈1,这样的字典序才能尽可能的小.且按这种操作,序列输出是固定的,所以只要模拟就可以了.

我们进行黑白染色的时候,从第一个元素开始,先染黑色.完成后,所有黑色的点都应该进入栈1,那白色的点都应该进入栈2.在知道点应该进入的栈之后,直接模拟就可以了.

某个元素进入栈之后,如果该元素可以`接入`当前已经输出的序列,就那应该把它弹出,然后检查两个栈的顶,也进行这样的操作,直到栈为空或者不符合条件了.

## 代码

```c
/*-----------------
* author: Rainboy
* email: rainboylvx@qq.com
* time: 2019年 05月 08日 星期三 09:51:11 CST
* problem:  luogu-1155
*----------------*/
#include <stack>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int INF = 0x7fffffff;
stack<int> s1,s2;
stack<int> _sort;
int n;
int a[1005];
int f[1005];
bool color[1005];
int vis[1005];
#define maxn 1000*1000


/* ================= 向量星 =================*/
int head[maxn];
int edge_cnt = 0;
struct _e{
    int u,v,w,next;
}e[maxn];

void inline xlx_init(){
    edge_cnt = 0;
    memset(head,-1,sizeof(head));
}

void addEdge(int u,int v){
    edge_cnt++;
    e[edge_cnt].u = u;
    e[edge_cnt].v= v;
    e[edge_cnt].next = head[u];
    head[u] = edge_cnt;
}
/* ================= 向量星 end =================*/


void init(){
    memset(vis,0,sizeof(vis));
    xlx_init();
    int i,j;
    scanf("%d",&n);
    for (i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    f[n+1] = INF;
    a[n+1] = INF;
    for(i=n;i>=1;i--){ //求dp
        f[i] = min(f[i+1],a[i+1]);
    }

    /* 建立图 */
    for(i=1;i<n;i++){
        for(j=i+1;j<=n;j++){
            if( a[i] < a[j] && a[i] > f[j]){
                addEdge( a[i],a[j]);
                addEdge(a[j],a[i]);
            }
        }
    }

}

/* 黑白染色 */
bool dfs(int u,int pre){
    if( vis[u] == 0){
        vis[u] = 1;
        color[u] = !pre;
        int i;
        for(i=head[u];i!=-1;i= e[i].next){
            int v = e[i].v;
            if( dfs(v,!pre) == false)
                return false;
        }
    }
    else if( color[u] == pre){
        return false;
    }

    return true;
}

/* 序列输出 */
void _s_out(){
    while(1){
        
        if(!s1.empty() ){
            int u = s1.top();
            if(u == _sort.top()+1){
                printf("b ");
                s1.pop();
                _sort.push(u);
                continue;
            }
        }

        if(!s2.empty() ){
            int u = s2.top();
            if(u == _sort.top()+1){
                printf("d ");
                s2.pop();
                _sort.push(u);
                continue;
            }
        }


        break;
    }
}

int main(){
    init();
    int i;
    /* 判断 */
    for(i=1;i<=n;i++)
        if( !vis[ a[i] ] && dfs(a[i],0) == false){
            printf("0");
            return 0;
        }

    /*
     *for (i=1;i<=n;i++){
     *    printf("%d ",color[a[i]]);
     *}
     *printf("\n");
     */

    /*  模拟输出 */
    _sort.push(0);
    for(i=1;i<=n;i++){
        int u = a[i];
        if( color[u] == 1){ //黑
            s1.push(u);
            printf("a ");
            _s_out();
        }
        else {  //白
            s2.push(u);
            printf("c ");
            _s_out();
        }
    }
    _s_out();


    return 0;
}
```
