---
title: T1-神经网络
date: 2019-03-27 16:45
update: 2019-03-27 16:45
author: Rainboy
---

## 代码

```c
#include <cstdio>
#include <cstring>
#include <stack>
#include <vector>
using namespace std;

#define maxn 200
int n,p;
int c[maxn];
int U[maxn];
int out_degree[maxn];
int in_degree[maxn];


/* ================= 向量星 =================*/
int head[maxn];
int edge_cnt = 0;
struct _e{
    int u,v,w,next;
}e[maxn<<1];

void inline xlx_init(){
    edge_cnt = 0;
    memset(head,-1,sizeof(head));
}

void addEdge(int u,int v,int w){
    edge_cnt++;
    e[edge_cnt].u = u;
    e[edge_cnt].v= v;
    e[edge_cnt].w=w;
    e[edge_cnt].next = head[u];
    head[u] = edge_cnt;
}
/* ================= 向量星 end =================*/


/* ================= 向量星2 =================*/
int head2[maxn];
int edge_cnt2 = 0;
struct _e e2[maxn<<1];

void inline xlx_init2(){
    edge_cnt2 = 0;
    memset(head2,-1,sizeof(head2));
}

void addEdge2(int u,int v,int w){
    edge_cnt2++;
    e2[edge_cnt2].u = u;
    e2[edge_cnt2].v= v;
    e2[edge_cnt2].w=w;
    e2[edge_cnt2].next = head2[u];
    head2[u] = edge_cnt2;
}
/* ================= 向量星 end =================*/


struct kahn {
    stack<int> sta; //栈
    vector<int> in_degree;//每个点的入度
    vector<int> top_sort_list;
    int n; //点的数量

    kahn(){}
    kahn(int node_c){
        n = node_c;
        in_degree.resize(node_c+1);
    }

    void sort(){
        int i,j;
        for(i=1;i<=n;i++){  //默认点从1开始
                            //把所有的入度为0的点加入
            if(in_degree[i] == 0)
                sta.push(i);
        }

        while(!sta.empty()){ 
            int t = sta.top(); sta.pop();
            top_sort_list.push_back(t);
            for(i = head[t];i!=-1;i = e[i].next){
                int v =e[i].v;
                in_degree[v]--;
                if(in_degree[v] == 0)
                    sta.push(v);
            }
        }
    }

};

void init(){
}



int main(){
    xlx_init();
    xlx_init2();

    scanf("%d%d",&n,&p);
    kahn ka(n);

    int i;
    int t1,t2,t3;
    for (i=1;i<=n;i++){
        scanf("%d%d",&t1,&t2);
        c[i] = t1;
        U[i] = t2;
    }
    for (i=1;i<=p;i++){
        scanf("%d%d%d",&t1,&t2,&t3);
        addEdge(t1,t2,t3);
        addEdge2(t2,t1,t3);
        ka.in_degree[t2]++;//入度
        out_degree[t1]++;
        in_degree[t2]++;
    }

    ka.sort();
    
    //计算
    int j;
    for(i=0;i<(int)ka.top_sort_list.size();i++){
        /* 找前趋点 */
        int u = ka.top_sort_list[i];
        if( in_degree[u] == 0) //第一层的点不计算,这是一个坑点
            continue;
        for(j=head2[u];j!=-1;j=e2[j].next){
            int v = e2[j].v;
            if( c[v] > 0){
                int k = e2[j].w * c[v];
                c[u] +=k ;
            }
        }
        c[u] -= U[u];
    }

    bool all_zero = true;
    for(i=1;i<=n;i++){
        if(out_degree[i] == 0 && c[i] != 0){
            all_zero = false;
            break;
        }
    }

    if( all_zero)
        printf("NULL");
        
    else {
    for(i=1;i<=n;i++){
        //if( out_degree[i] == 0)
            //printf("out %d\n",i);
        if(out_degree[i] == 0 && c[i] > 0){
            printf("%d %d\n",i,c[i]);
        }
    }

    }

    return 0;
}
```

